<!DOCTYPE html>
<html lang="en-gb">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta property="og:title" content="Odin Documentation" />
  <meta property="og:description" content="Introduction This article is a basic tutorial for the programming language Odin. This tutorial assumes a basic knowledge of programming concepts such as variables, statements, and types. It is recommend to read the Getting started with Odin guide.
Hellope! To begin this tour, let us start with a modified version of the famous &ldquo;hello world&rdquo; program:
package main import &quot;core:fmt&quot; main :: proc() { fmt.println(&quot;Hellope!&quot;); }  Save this code to the file &ldquo;hellope." />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="https://odin-lang.org/docs/overview/" />
  
  <meta property="og:image" content="https://odin-lang.org/images/logo-slim.png" />
  



  <title>Odin Documentation - Odin Programming Language</title>
  <link rel="stylesheet" href="/css/normalize.css" />
  <link rel="stylesheet" href="/css/style.css" />
  <link rel="stylesheet" href="/highlight/style.css" />
  <script src="/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-67516878-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-67516878-2');
  </script>
</head>
<body>
<div class="wrapper">
<header>
  <nav>
    <h1 id="logo"><a href="/"><img src="/images/logo-slim.png" alt="Odin" id="nav-log"></a></h1>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      <li><a href="/docs/">Documents</a></li>
      <li><a href="/help/">Help</a></li>
      <li><a href="/blog/">Blog</a></li>
      <li><a href="https://github.com/odin-lang/Odin">GitHub</a></li>
    </ul>
  </nav>
</header>

<main>
<article class="article-meta">
<header>
	<h1>Odin Documentation</h1>
	
	<div class="info">
		
		<p>
		
		</p>
	</div>
</header>
<b>Warning:</b> This is a work in progress and is subject to change.<hr>


<aside>
<nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#hellope">Hellope!</a></li>
<li><a href="#lexical-elements-and-literals">Lexical elements and literals</a>
<ul>
<li><a href="#comments">Comments</a></li>
<li><a href="#string-and-character-literals">String and character literals</a>
<ul>
<li><a href="#escape-characters">Escape Characters</a></li>
</ul></li>
<li><a href="#numbers">Numbers</a></li>
</ul></li>
<li><a href="#variable-declarations">Variable declarations</a></li>
<li><a href="#assignment-statements">Assignment statements</a></li>
<li><a href="#constant-declarations">Constant declarations</a></li>
<li><a href="#packages">Packages</a>
<ul>
<li><a href="#import-statement">Import statement</a></li>
<li><a href="#exported-names">Exported names</a></li>
</ul></li>
<li><a href="#control-flow-statements">Control flow statements</a>
<ul>
<li><a href="#for-statement">For statement</a>
<ul>
<li><a href="#basic-for-loop">Basic for loop</a></li>
<li><a href="#range-based-for-loop">Range-based for loop</a></li>
</ul></li>
<li><a href="#if-statement">If statement</a></li>
<li><a href="#switch-statement">Switch statement</a></li>
<li><a href="#defer-statement">Defer statement</a></li>
<li><a href="#when-statement">When statement</a></li>
<li><a href="#branch-statements">Branch statements</a>
<ul>
<li><a href="#break-statement">Break statement</a></li>
<li><a href="#continue-statement">Continue statement</a></li>
<li><a href="#fallthrough-statement">Fallthrough statement</a></li>
</ul></li>
</ul></li>
<li><a href="#procedures">Procedures</a>
<ul>
<li><a href="#parameters">Parameters</a></li>
<li><a href="#multiple-results">Multiple results</a></li>
<li><a href="#named-results">Named results</a></li>
<li><a href="#named-arguments">Named arguments</a></li>
<li><a href="#default-values">Default values</a></li>
<li><a href="#explicit-procedure-overloading">Explicit procedure overloading</a>
<ul>
<li><a href="#rationale-behind-explicit-overloading">Rationale behind explicit overloading</a></li>
</ul></li>
</ul></li>
<li><a href="#basic-types">Basic types</a>
<ul>
<li><a href="#zero-values">Zero values</a></li>
<li><a href="#type-conversion">Type conversion</a>
<ul>
<li><a href="#cast-operator">Cast operator</a></li>
<li><a href="#transmute-operator">Transmute operator</a></li>
</ul></li>
<li><a href="#untyped-types">Untyped types</a></li>
<li><a href="#auto-cast-operation">Auto cast operation</a></li>
<li><a href="#built-in-constants-and-values">Built-in constants and values</a></li>
<li><a href="#cstring-type">cstring type</a></li>
</ul></li>
<li><a href="#advanced-types">Advanced types</a>
<ul>
<li><a href="#type-alias">Type alias</a></li>
<li><a href="#distinct-types">Distinct types</a></li>
<li><a href="#fixed-arrays">Fixed arrays</a>
<ul>
<li><a href="#array-programming">Array programming</a></li>
</ul></li>
<li><a href="#slices">Slices</a>
<ul>
<li><a href="#slice-literals">Slice literals</a></li>
<li><a href="#slice-shorthand">Slice shorthand</a></li>
<li><a href="#nil-slices">Nil slices</a></li>
</ul></li>
<li><a href="#dynamic-arrays">Dynamic arrays</a>
<ul>
<li><a href="#appending-to-a-dynamic-array">Appending to a dynamic array</a></li>
<li><a href="#making-and-deleting-slices-and-dynamic-arrays">Making and deleting slices and dynamic arrays</a></li>
</ul></li>
<li><a href="#enumerations">Enumerations</a>
<ul>
<li><a href="#implicit-selector-expression">Implicit Selector Expression</a></li>
</ul></li>
<li><a href="#bit-sets">Bit sets</a></li>
<li><a href="#pointers">Pointers</a></li>
<li><a href="#structs">Structs</a>
<ul>
<li><a href="#struct-literals">Struct literals</a></li>
<li><a href="#struct-tags">Struct tags</a></li>
</ul></li>
<li><a href="#unions">Unions</a>
<ul>
<li><a href="#type-switch-statement">Type switch statement</a></li>
</ul></li>
<li><a href="#maps">Maps</a></li>
<li><a href="#procedure-type">Procedure type</a>
<ul>
<li><a href="#calling-conventions">Calling conventions</a></li>
</ul></li>
<li><a href="#bit-fields">Bit fields</a></li>
<li><a href="#typeid-type">&lsquo;typeid&rsquo; type</a></li>
<li><a href="#any-type">&lsquo;any&rsquo; Type</a></li>
</ul></li>
<li><a href="#using-statement">Using statement</a>
<ul>
<li><a href="#using-statement-with-structs">Using statement with structs</a></li>
<li><a href="#subtype-polymorphism">Subtype polymorphism</a></li>
</ul></li>
<li><a href="#implicit-context-system">Implicit context system</a>
<ul>
<li><a href="#allocators">Allocators</a></li>
</ul></li>
<li><a href="#foreign-system">Foreign system</a></li>
<li><a href="#parametric-polymorphism">Parametric polymorphism</a>
<ul>
<li><a href="#explicit-parametric-polymorphism">Explicit parametric polymorphism</a>
<ul>
<li><a href="#procedures-1">Procedures</a></li>
<li><a href="#data-types">Data types</a></li>
</ul></li>
<li><a href="#implicit-parametric-polymorphism">Implicit parametric polymorphism</a>
<ul>
<li><a href="#procedures-2">Procedures</a></li>
<li><a href="#specialization">Specialization</a></li>
</ul></li>
</ul></li>
<li><a href="#useful-idioms">Useful idioms</a>
<ul>
<li><a href="#basic-idioms">Basic idioms</a>
<ul>
<li><a href="#if-statements-with-initialization">If-statements with initialization</a></li>
<li><a href="#iterating-through-slices-of-structs-by-value-or-by-reference">Iterating through slices of structs by value or by reference</a></li>
<li><a href="#defer-if">&lsquo;defer if&rsquo;</a></li>
</ul></li>
<li><a href="#advanced-idioms">Advanced idioms</a></li>
</ul></li>
<li><a href="#extra-information">Extra information</a></li>
</ul></li>
</ul>
</nav>
</aside>



<h2 id="introduction">Introduction</h2>

<p>This article is a basic tutorial for the programming language <em>Odin</em>. This tutorial assumes a basic knowledge of programming concepts such as variables, statements, and types. It is recommend to read the <a href="https://github.com/odin-lang/Odin/wiki#getting-started-with-odin">Getting started with Odin</a> guide.</p>

<h2 id="hellope">Hellope!</h2>

<p>To begin this tour, let us start with a modified version of the famous &ldquo;hello world&rdquo; program:</p>

<pre><code class="language-odin">package main

import &quot;core:fmt&quot;

main :: proc() {
    fmt.println(&quot;Hellope!&quot;);
}
</code></pre>

<p>Save this code to the file &ldquo;hellope.odin&rdquo;. Now compile and run it:</p>

<pre><code>odin run hellope.odin
</code></pre>

<p>The <code>run</code> command compiles the <code>.odin</code> file to an executable and then runs that executable after compilation. If you do not wish to run the executable after compilation, the <code>build</code> command can be used.</p>

<pre><code>odin build hellope.odin
</code></pre>

<h2 id="lexical-elements-and-literals">Lexical elements and literals</h2>

<h3 id="comments">Comments</h3>

<p>Comments can be anywhere outside of a string or character literal. Single line comments begin with <code>//</code>:</p>

<pre><code class="language-odin">// A comment

my_integer_variable: int; // A comment for documentation
</code></pre>

<p>Multi-line comments begin with <code>/*</code> and end with <code>*/</code>. Multi-line comments can be also be nested (unlike in C):</p>

<pre><code class="language-odin">/*
    You can have any text or code here and
    have it be commented.
    /*
        NOTE: comments can be nested!
    */
*/
</code></pre>

<p>Comments are parsed as tokens within the compiler. This is to allow for future work on automatic documentation tools.</p>

<h3 id="string-and-character-literals">String and character literals</h3>

<p>String literals are enclosed in double quotes and character literals in single quotes. Special characters are escaped with a backslash <code>\</code>.</p>

<pre><code class="language-odin">&quot;This is a string&quot;
'A'
'\n' // newline character
&quot;C:\\Windows\\notepad.exe&quot;
</code></pre>

<p>Raw string literals are enclosed in single back ticks.</p>

<pre><code class="language-odin">`C:\Windows\notepad.exe`
</code></pre>

<p>The length of a string can be found using the built-in <code>len</code> proc:</p>

<pre><code class="language-odin">len(&quot;Foo&quot;)
len(some_string)
</code></pre>

<p>If the string passed to <code>len</code> is a compile-time constant, the value from <code>len</code> will be a compile-time constant.</p>

<h4 id="escape-characters">Escape Characters</h4>

<ul>
<li><code>\a</code> - bell (BEL)</li>
<li><code>\b</code> - backspace (BS)</li>
<li><code>\e</code> - escape (ESC)</li>
<li><code>\f</code> - form feed (FF)</li>
<li><code>\n</code> - newline</li>
<li><code>\r</code> - carriage return</li>
<li><code>\t</code> - tab</li>
<li><code>\v</code> - vertical tab (VT)</li>
<li><code>\\</code> - backslash</li>
<li><code>\&quot;</code> - double quote (if needed)</li>
<li><code>\'</code> - single quote (if needed)</li>
<li><code>\NN</code>- octal 4 bit character (2 digits)</li>
<li><code>\xNN</code> - hexadecimal 8 bit character (2 digits)</li>
<li><code>\uNNNN</code> - hexadecimal 16-bit Unicode character UTF-8 encoded (4 digits)</li>
<li><code>\UNNNNNN</code> - hexadecimal 24-bit Unicode character UTF-8 encoded (6 digits)</li>
</ul>

<h3 id="numbers">Numbers</h3>

<p>Numerical literals are written similar to most other programming languages. A useful feature in Odin is that underscores are allowed for better readability: <code>1_000_000_000</code> (one billion). A number that contains a dot is a floating point literal: <code>1.0e9</code> (one billion). If a number literal is suffixed with <code>i</code>, is an imaginary number literal: <code>2i</code> (2 multiply the square root of -1).</p>

<p>Binary literals are prefixed with <code>0b</code>, octal literals with <code>0o</code>, and hexadecimal literals <code>0x</code>. A leading zero does not produce an octal constant (unlike C).</p>

<p>In Odin, if a number constant is possible to be represented by a type without precision loss, it will automatically convert to that type.</p>

<pre><code class="language-odin">x: int = 1.0; // A float literal but it can be represented by an integer without precision loss
</code></pre>

<p>Constant literals are &ldquo;untyped&rdquo; which means that they can implicitly convert to a type.</p>

<pre><code class="language-odin">x: int; // `x` in typed of type `int`
x = 1; // `1` is an untyped integer literal which can implicitly convert to `int`
</code></pre>

<h2 id="variable-declarations">Variable declarations</h2>

<p>A variable declaration declares a new variable for that current scope.</p>

<pre><code class="language-odin">x: int; // declares x to have type `int`
y, z: int; // declares y and z to have type `int`
</code></pre>

<p>Variables are initialized to zero by default unless specified otherwise.</p>

<h2 id="assignment-statements">Assignment statements</h2>

<p>The assignment statement assigns a new value to a variable/location:</p>

<pre><code class="language-odin">x: int = 123; // declares a new variable `x` with type `int` and assigns a value to it
x = 637; // assigns a new value to `x`
</code></pre>

<p><code>=</code> is the assignment operator.</p>

<p>You can assign multiple variables with it:</p>

<pre><code class="language-odin">x, y := 1, &quot;hello&quot;; // declares `x` and `y` and infers the types from the assignments
y, x = &quot;bye&quot;, 5;
</code></pre>

<p><strong>Note:</strong> <code>:=</code> is two tokens, <code>:</code> and <code>=</code>. The following are all equivalent:</p>

<pre><code class="language-odin">x: int = 123;
x:     = 123; // default type for an integer literal is `int`
x := 123;
</code></pre>

<h2 id="constant-declarations">Constant declarations</h2>

<p>Constants are entities (symbols) which have an assigned value. The constant&rsquo;s value cannot be changed. The constant&rsquo;s value must be able to be evaluated at compile time:</p>

<pre><code class="language-odin">x :: &quot;what&quot;; // constant `x` has the untyped string value &quot;what&quot;
</code></pre>

<p>Constants can be explicitly typed like a variable declaration:</p>

<pre><code class="language-odin">y : int : 123;
z :: y + 7; // constant computations are possible
</code></pre>

<h2 id="packages">Packages</h2>

<p>Every Odin program is made up of packages. Programs begin running in the package <code>main</code>.</p>

<h3 id="import-statement">Import statement</h3>

<p>The following program imports the the <code>fmt</code> and <code>os</code> packages from the <code>core</code> library collection.</p>

<pre><code class="language-odin">package main

import &quot;core:fmt&quot;
import &quot;core:os&quot;

main :: proc() {
}
</code></pre>

<p>The <code>core:</code> prefix is to state where the import is meant to look; this is called a library collection. If no prefix is present, the import will look relative to current file.</p>

<p><strong>Note</strong>: By convention, the package name is the same as the last element in the import path. <code>&quot;core:fmt&quot;</code> package comprises of files that begin with the statement <code>package fmt</code>. However, this is not enforced by the compiler, which means that default name for the import name will be determined by the last element in the import path if possible.</p>

<p>A different import name can be used over the default package name:</p>

<pre><code>import &quot;core:fmt&quot;
import foo &quot;core:fmt&quot; // reference a package by different name
</code></pre>

<h3 id="exported-names">Exported names</h3>

<p>In Odin, a name is exported from a package if it does <em>not</em> begin with an underscore <code>_</code>. For example, <code>foo</code> is an exported name, but <code>_bar</code> will not be exported.</p>

<p>Import names are not exported by the package as they are local to that file in the package and not the package itself.</p>

<p>The attribute <code>@(private)</code> can be applied to an entity to prevent it from being exported from a package.</p>

<pre><code class="language-odin">@(private)
my_variable: int;
</code></pre>

<h2 id="control-flow-statements">Control flow statements</h2>

<h3 id="for-statement">For statement</h3>

<p>Odin has only one loop statement, the <code>for</code> loop.</p>

<h4 id="basic-for-loop">Basic for loop</h4>

<p>A basic <code>for</code> loop has three components separated by semicolons:</p>

<ul>
<li>The initial statement: executed before the first iteration</li>
<li>The condition expression: evaluated before every iteration</li>
<li>The post statement: executed at the end of every iteration</li>
</ul>

<p>The loop will stop executing when the condition is evaluates to <code>false</code>.</p>

<pre><code class="language-odin">for i := 0; i &lt; 10; i += 1 {
    fmt.println(i);
}
</code></pre>

<p><strong>Note:</strong> Unlike other languages like C, there are no parentheses <code>( )</code> surrounding the three components. Braces <code>{ }</code> or a <code>do</code> are always required.</p>

<pre><code class="language-odin">for i := 0; i &lt; 10; i += 1 { }
for i := 0; i &lt; 10; i += 1 do single_statement();
</code></pre>

<p>The initial and post statements are optional:</p>

<pre><code class="language-odin">i := 0;
for ; i &lt; 10; {
    i += 1;
}
</code></pre>

<p>These semicolons can be dropped. This <code>for</code> loop is equivalent to C&rsquo;s <code>while</code> loop:</p>

<pre><code class="language-odin">i := 0;
for i &lt; 10 {
    i += 1;
}
</code></pre>

<p>If the condition is omitted, this produces an infinite loop:</p>

<pre><code class="language-odin">for {
}
</code></pre>

<h4 id="range-based-for-loop">Range-based for loop</h4>

<p>The basic for loop</p>

<pre><code class="language-odin">for i := 0; i &lt; 10; i += 1 {
    fmt.println(i);
}
</code></pre>

<p>can also be written</p>

<pre><code class="language-odin">for i in 0..&lt;10 {
    fmt.println(i);
}
// or
for i in 0..9 {
    fmt.println(i);
}
</code></pre>

<p>where <code>a..b</code> denotes an open interval <code>[a,b]</code>, i.e. the upper limit is <em>inclusive</em>, and <code>a..&lt;b</code> denotes a half-open interval <code>[a,b)</code>, i.e. the upper limit is <em>exclusive</em>.</p>

<p>Certain built-in types can be iterated over:</p>

<pre><code class="language-odin">for character in some_string {
    fmt.println(character);
}
for value in some_array {
    fmt.println(value);
}
for value in some_slice {
    fmt.println(value);
}
for value in some_dynamic_array {
    fmt.println(value);
}
for value in some_map {
    fmt.println(value);
}
</code></pre>

<p>Alternatively a second index value can be added:</p>

<pre><code class="language-odin">for character, index in some_string {
    fmt.println(index, character);
}
for value, index in some_array {
    fmt.println(index, value);
}
for value, index in some_slice {
    fmt.println(index, value);
}
for value, index in some_dynamic_array {
    fmt.println(index, value);
}
for key, value in some_map {
    fmt.println(key, value);
}
</code></pre>

<p>The iterated values are <em>copies</em> and cannot be written to. The following idiom is useful for iterating over a container in a by-reference manner:</p>

<pre><code class="language-odin">for _, i in some_slice {
    some_slice[i] = something;
}
</code></pre>

<h3 id="if-statement">If statement</h3>

<p>Odin&rsquo;s <code>if</code> statements do not need to be surrounded by parentheses <code>( )</code> but braces <code>{ }</code> or <code>do</code> is required.</p>

<pre><code class="language-odin">if x &gt;= 0 {
    fmt.println(&quot;x is positive&quot;);
}
</code></pre>

<p>Like <code>for</code>, the <code>if</code> statement can start with an initial statement to execute before the condition. Variables declared by the initial statement are only in the scope of that <code>if</code> statement.</p>

<pre><code class="language-odin">if x := foo(); x &lt; 0 {
    fmt.println(&quot;x is negative&quot;);
}
</code></pre>

<p>Variables declared inside an <code>if</code> initial statement are also available to any of the <code>else</code> blocks:</p>

<pre><code class="language-odin">if x := foo(); x &lt; 0 {
    fmt.println(&quot;x is negative&quot;);
} else if x == 0 {
    fmt.println(&quot;x is zero&quot;);
} else {
    fmt.println(&quot;x is positive&quot;);
}
</code></pre>

<h3 id="switch-statement">Switch statement</h3>

<p>A switch statement is another way to write a sequence of if-else statements. In Odin, the default case is denoted as a case without any expression.</p>

<pre><code class="language-odin">package main

import &quot;core:fmt&quot;
import &quot;core:os&quot;

main :: proc() {
    switch arch := ODIN_ARCH; arch {
    case &quot;386&quot;:
        fmt.println(&quot;32 bit&quot;);
    case &quot;amd64&quot;:
        fmt.println(&quot;64 bit&quot;);
    case: // default
        fmt.println(&quot;Unsupported architecture&quot;);
    }
}
</code></pre>

<p>Odin&rsquo;s <code>switch</code> is like one in C or C++, except that Odin only runs the selected case. This means that a <code>break</code> statement is not needed at the end of each case. Another important difference is that the case values need not be integers nor constants.</p>

<p>To achieve a C-like fall through into the next case block, the keyword <a href="#fallthrough-statement"><code>fallthrough</code></a> can be used.</p>

<p>Switch cases are evaluated from top to bottom, stopping when a case succeeds. For example:</p>

<pre><code class="language-odin">switch i {
case 0:
case foo():
}
</code></pre>

<p><code>foo()</code> does not get called if <code>i==0</code>. If all the case values are constants, the compiler may optimize the switch statement into a jump table (like C).</p>

<p>A <code>switch</code> statement without a condition is the same as <code>switch true</code>. This can be used to write a clean and long if-else chain and have the ability to <a href="#fallthrough-statement"><code>break</code></a> if needed</p>

<pre><code class="language-odin">switch {
case x &lt; 0:
    fmt.println(&quot;x is negative&quot;);
case x == 0:
    fmt.println(&quot;x is zero&quot;);
case:
    fmt.println(&quot;x is positive&quot;);
}
</code></pre>

<p>A <code>switch</code> statement can also use ranges like a range-based loop:</p>

<pre><code class="language-odin">switch c {
case 'A'..'Z', 'a'..'z', '0'..'9':
    fmt.println(&quot;c is alphanumeric&quot;);
}

switch x {
case 0..&lt;10:
    fmt.println(&quot;units&quot;);
case 10..&lt;13:
    fmt.println(&quot;pre-teens&quot;);
case 13..&lt;20:
    fmt.println(&quot;teens&quot;);
case 20..&lt;30:
    fmt.println(&quot;twenties&quot;);
}
</code></pre>

<h3 id="defer-statement">Defer statement</h3>

<p>A defer statement defers the execution of a statement until the end of the scope it is in.</p>

<p>The following will print <code>4</code> then <code>234</code>:</p>

<pre><code class="language-odin">package main

import &quot;core:fmt&quot;

main :: proc() {
    x := 123;
    defer fmt.println(x);
    {
        defer x = 4;
        x = 2;
    }
    fmt.println(x);

    x = 234;
}
</code></pre>

<p>You can defer an entire block too:</p>

<pre><code class="language-odin">{
    defer {
        foo();
        bar();
    }
    defer if cond {
        bar();
    }
}
</code></pre>

<p>Defer statements are executed in the reverse order that they were declared:</p>

<pre><code class="language-odin">defer fmt.println(&quot;1&quot;);
defer fmt.println(&quot;2&quot;);
defer fmt.println(&quot;3&quot;);
</code></pre>

<p>Will print <code>3</code>, <code>2</code>, and then <code>1</code>.</p>

<p>A real world use case for <code>defer</code> may be something like the following:</p>

<pre><code class="language-odin">f, err := os.open(&quot;my_file.txt&quot;);
if err != os.ERROR_NONE {
    // handle error
}
defer os.close(f);
// rest of code
</code></pre>

<p>In this case, it acts akin to am explicit C++ destructor however, the error handling is basic control flow.</p>

<h3 id="when-statement">When statement</h3>

<p>The <code>when</code> statement is almost identical to the <code>if</code> statement but with some differences:</p>

<ul>
<li>Each condition must be a constant expression as a <code>when</code> statement is evaluated at compile time.</li>
<li>The statements within a branch do not create a new scope</li>
<li>The compiler checks the semantics and code <strong>only</strong> for statements that belong to the first condition that is <code>true</code></li>
<li>An initial statement is not allowed in a <code>when</code> statement</li>
<li><code>when</code> statements are allowed at file scope</li>
</ul>

<p>Example:</p>

<pre><code class="language-odin">when ODIN_ARCH == &quot;386&quot; {
    fmt.println(&quot;32 bit&quot;);
} else when ODIN_ARCH == &quot;amd64&quot; {
    fmt.println(&quot;64 bit&quot;);
} else {
    fmt.println(&quot;Unsupported architecture&quot;);
}
</code></pre>

<p>The <code>when</code> statement is very useful for writing platform specific code. This is akin to the <code>#if</code> construct in C&rsquo;s preprocessor however, in Odin, it is type checked.</p>

<h3 id="branch-statements">Branch statements</h3>

<h4 id="break-statement">Break statement</h4>

<p>A for loop or a switch statement can be left prematurely with a <code>break</code> statement. It leaves the innermost construct, unless a label of a construct is given:</p>

<pre><code class="language-odin">for cond {
    switch {
    case:
        if cond {
            break; // break out of the `switch` statement
        }
    }

    break; // break out of the `for` statement
}

loop: for cond1 {
    for cond2 {
        break loop; // leaves both loops
    }
}
</code></pre>

<h4 id="continue-statement">Continue statement</h4>

<p>As in many programming languages, a <code>continue</code> statement starts the next iteration of a loop prematurely:</p>

<pre><code class="language-odin">for cond {
    if get_foo() {
        continue;
    }
    fmt.println(&quot;Hellope&quot;);
}
</code></pre>

<h4 id="fallthrough-statement">Fallthrough statement</h4>

<p>Odin&rsquo;s <code>switch</code> is like one in C or C++, except that Odin only runs the selected case. This means that a <code>break</code> statement is not needed at the end of each case. Another important difference is that the case values need not be integers nor constants.</p>

<p><code>fallthrough</code> can be used to explicitly fall through into the next case block:</p>

<pre><code class="language-odin">switch i {
case 0:
    foo();
    fallthrough;
case 1:
    bar();
}
</code></pre>

<h2 id="procedures">Procedures</h2>

<p>In Odin, a procedure is something that can do work, which some languages call <em>functions</em> or <em>methods</em>. A procedure literal in Odin is defined with the <code>proc</code> keyword:</p>

<pre><code class="language-odin">fibonacci :: proc(n: int) -&gt; int {
    switch {
    case n &lt; 1:
        return 0;
    case n == 1:
        return 1;
    }
    return fibonacci(n-1) + fibonacci(n-2);
}

fmt.println(fibonacci(3));
</code></pre>

<h3 id="parameters">Parameters</h3>

<p>Procedures can take zero or many parameters, the following example is basic procedure that multiplies two integers together:</p>

<pre><code class="language-odin">multiply :: proc(x: int, y: int) -&gt; int {
    return x * y;
}
fmt.println(multiply(137, 432));
</code></pre>

<p>When two or more consecutive parameters share a type, you can omit the other types from previous names, like with variable declarations. In this example: <code>x: int, y: int</code> can be shortened to <code>x, y: int</code>, for example:</p>

<pre><code class="language-odin">multiply :: proc(x, y: int) -&gt; int {
    return x * y;
}
fmt.println(multiply(137, 432));
</code></pre>

<p>Continuing the C family tradition, everything in Odin is passed by value. The procedure always gets a copy of the thing that has been passed, as if there was an assignment statement to the procedure parameter.</p>

<p>Passing a pointer value makes a copy of the pointer, not the data it points to it. Slices, dynamic arrays, and maps behave like pointers in this case (Internally they are structures that contain values, which include pointers and the &ldquo;structure&rdquo; is passed by value).</p>

<p>Parameters in a procedure body will be mutable but as they are copies, they will not affect the original values.</p>

<h3 id="multiple-results">Multiple results</h3>

<p>A procedure in Odin can return any number of results. For example:</p>

<pre><code class="language-odin">swap :: proc(x, y: int) -&gt; (int, int) {
    return y, x;
}
a, b := swap(1, 2);
fmt.println(a, b); // 2 1
</code></pre>

<h3 id="named-results">Named results</h3>

<p>Return values in Odin may be named. If so, they are treated as variables defined at the top of the procedure, like input parameters. A <code>return</code> statement without arguments returns the named return value. &ldquo;Naked&rdquo; return statements should only be used in short procedures as it reduces clarity when reading.</p>

<pre><code class="language-odin">do_math :: proc(input: int) -&gt; (x, y: int) {
    x = 2*input + 1;
    y = 3*input / 5;
    return x, y;
}
do_math_with_naked_return :: proc(input: int) -&gt; (x, y: int) {
    x = 2*input + 1;
    y = 3*input / 5;
    return;
}
</code></pre>

<h3 id="named-arguments">Named arguments</h3>

<p>When calling a procedures, it is not clear in which order parameters might appear. Therefore, the arguments can be named, like a struct literal, to make it clear which argument a parameter is for:</p>

<pre><code class="language-odin">create_window :: proc(title: string, x, y: int, width, height: int, monitor: ^Monitor) -&gt; (^Window, Window_Error) {...}

window, err := create_window(title=&quot;Hellope Title&quot;, monitor=nil, width=854, height=480, x=0, y=0);
</code></pre>

<p><strong>Note:</strong> Currently, mixing named and non-named arguments is not allowed. This is subject to change if it is deemed necessary.</p>

<h3 id="default-values">Default values</h3>

<p>The <code>create_window</code> procedure may be easier to use if default values are provided which will be used if they are not specified:</p>

<pre><code class="language-odin">create_window :: proc(title: string, x := 0, y := 0, width := 854, height := 480, monitor: ^Monitor = nil) -&gt; (^Window, Window_Error) {...}

window1, err1 := create_window(&quot;Title1&quot;);
window2, err2 := create_window(title=&quot;Title1&quot;, width=640, height=360);
</code></pre>

<p><strong>Note:</strong> These default values must be constant or the <code>nil</code> value (if that type supports it).</p>

<h3 id="explicit-procedure-overloading">Explicit procedure overloading</h3>

<p>Unlike other languages, Odin provides the ability to explicitly overload procedures:</p>

<pre><code class="language-odin">bool_to_string :: proc(b: bool) -&gt; string {...}
int_to_string  :: proc(i: int)  -&gt; string {...}

to_string :: proc{bool_to_string, int_to_string};
</code></pre>

<h4 id="rationale-behind-explicit-overloading">Rationale behind explicit overloading</h4>

<p>The design goals of Odin were explicitness and simplicity. Implicit procedure overloading complicates the scoping system. In C++, you cannot nest procedures within procedures so all procedure look-ups are done at the global scope. In Odin, procedures can be nested within procedures and as a result, determining which procedure should be used, in the case of implicit overloading, is complex.</p>

<p>Explicit overloading has many advantages:</p>

<ul>
<li>Explicitness of what is overloaded</li>
<li>Able to refer to the specific procedure if needed</li>
<li>Clear which scope the entity name belongs to</li>
</ul>

<pre><code class="language-odin">foo :: proc{
    foo_bar,
    foo_baz,
    foo_baz2,
    another_thing_entirely,
};
</code></pre>

<h2 id="basic-types">Basic types</h2>

<p>Odin&rsquo;s basic types are:</p>

<pre><code class="language-odin">bool b8 b16 b32 b64

int  i8 i16 i32 i64 i128
uint u8 u16 u32 u64 u128 uintptr

// endian specific integers
i16le i32le i64le i128le u16le u32le u64le u128le // little endian
i16be i32be i64be i128be u16be u32be u64be u128be // big endian

f32 f64

complex64 complex128

rune // signed 32 bit integer
     // represents a Unicode code point
     // is a distinct type to `i32`

string cstring

rawptr

typeid
any
</code></pre>

<p>The <code>int</code>, <code>uint</code>, and <code>uintptr</code> types are pointer sized. When you need an integer value, you should default to using <code>int</code> unless you have a specific reason to use a sized or unsigned integer type</p>

<p><strong>Note:</strong> The Odin <code>string</code> type stores the pointer to the data and the length of the string. <code>cstring</code> is used to interface with foreign libraries written in/for C that use zero-terminated strings.</p>

<h3 id="zero-values">Zero values</h3>

<p>Variables declared without an explicit initial value are given their <em>zero</em> value.</p>

<p>The zero value is:</p>

<ul>
<li><code>0</code> for numeric and rune types</li>
<li><code>false</code> for boolean types</li>
<li><code>&quot;&quot;</code> (the empty string) for strings</li>
<li><code>nil</code> for pointer, typeid, and any types.</li>
</ul>

<h3 id="type-conversion">Type conversion</h3>

<p>The expression <code>T(v)</code> converts the value <code>v</code> to the type <code>T</code>.</p>

<pre><code class="language-odin">i: int = 123;
f: f64 = f64(i);
u: u32 = u32(f);
</code></pre>

<p>or with type inference:</p>

<pre><code class="language-odin">i := 123;
f := f64(i);
u := u32(f);
</code></pre>

<p>Unlike C, assignments between values of a different type require an explicit conversion.</p>

<h4 id="cast-operator">Cast operator</h4>

<p>The <code>cast</code> operator can also be used to do the same thing:</p>

<pre><code class="language-odin">i := 123;
f := cast(f64)i;
u := cast(u32)f;
</code></pre>

<p>This is useful is some contexts but has the same semantic meaning.</p>

<h4 id="transmute-operator">Transmute operator</h4>

<p>The <code>transmute</code> operator is a bit cast conversion between two types of the same size:</p>

<pre><code class="language-odin">f := f32(123);
u := transmute(u32)f;
</code></pre>

<h3 id="untyped-types">Untyped types</h3>

<p>In the Odin type system, certain expressions will have an &ldquo;untyped&rdquo; type. An untyped type can implicitly convert to a &ldquo;typed&rdquo; type. The following are the</p>

<h3 id="auto-cast-operation">Auto cast operation</h3>

<p>The <code>auto_cast</code> operator automatically casts an expression to the destination&rsquo;s type if possible:</p>

<pre><code class="language-odin">x: f32 = 123;
y: int = auto_cast x;
</code></pre>

<p><strong>Note:</strong> This operation is only recommended to be used for prototyping and quick tests. Please do not abuse it.</p>

<h3 id="built-in-constants-and-values">Built-in constants and values</h3>

<pre><code class="language-odin">false // untyped boolean constant equivalent to the expression 0!=0
true  // untyped boolean constant equivalent to the expression 0==0
nil   // untyped nil value used for certain values
---   // untyped undefined value used to explicitly not initialize a variable
</code></pre>

<p><code>---</code> is useful if you want to explicitly not initialize a variable with any default value:</p>

<pre><code class="language-odin">x: int; // initialized with its zero value
y: int = ---; // uses uninitialized memory
</code></pre>

<p>This is the default behaviour in C.</p>

<h3 id="cstring-type">cstring type</h3>

<p>The <code>cstring</code> type is a c-style string value, which is zero-terminated. It is equivalent to <code>char const *</code> in C. Its primary purpose is for easy interfacing with C. Please see the <a href="#foreign-system">foreign system</a> for more information.</p>

<p>A <code>cstring</code> is easily convertible to an Odin <code>string</code> however, to convert a <code>string</code> to a <code>cstring</code> it requires allocations if the value is not constant.</p>

<pre><code class="language-odin">str:  string  = &quot;Hellope&quot;;
cstr: cstring = &quot;Hellope&quot;; // constant literal;
cstr2 := string(cstring);  // O(n) conversion as it requires search from the zero-terminator
nstr  := len(str);  // O(1)
ncstr := len(cstr); // O(n)
</code></pre>

<h2 id="advanced-types">Advanced types</h2>

<h3 id="type-alias">Type alias</h3>

<p>You can alias a named type with another name:</p>

<pre><code class="language-odin">My_Int :: int;
#assert(My_Int == int);
</code></pre>

<h3 id="distinct-types">Distinct types</h3>

<p>A distinct type allows for the creation of a new type with the same underlying semantics.</p>

<pre><code class="language-odin">My_Int :: distinct int;
#assert(My_Int != int);
</code></pre>

<p>Aggregate types (struct, enum, union, bit_field) will always be distinct even when named.</p>

<pre><code class="language-odin">Foo :: struct {};
#assert(Foo != struct{});
</code></pre>

<h3 id="fixed-arrays">Fixed arrays</h3>

<p>An array is a simplified fixed length container. Each element in an array has the same type. An array&rsquo;s index can be any integer, character, or enumeration type.</p>

<p>An array can be constructed like the following:</p>

<pre><code class="language-odin">x := [5]int{1, 2, 3, 4, 5};
for i in 0..4 {
    fmt.println(x[i]);
}
</code></pre>

<p>The notation <code>x[i]</code> is used to access the i-th element of <code>x</code>; and 0-index based (like C).</p>

<p>The built-in <code>len</code> proc returns the array&rsquo;s length.</p>

<pre><code class="language-odin">x: [5]int;
#assert(len(x) == 5);
</code></pre>

<p>Array access is always bounds checked (at compile-time and at runtime). This can be disabled and enabled at a per block level with the <code>#no_bounds_check</code> and <code>#bounds_check</code> directives, respectively:</p>

<pre><code class="language-odin">#no_bounds_check {
    x[n] = 123; // n could be in out of range of valid indices
}
</code></pre>

<p><code>#no_bounds_check</code> can be used to improve performance when the bounds are known to not exceed.</p>

<h4 id="array-programming">Array programming</h4>

<p>Odin&rsquo;s fixed length arrays support <a href="https://en.wikipedia.org/wiki/Array_programming">array programming</a>.</p>

<p>Example:</p>

<pre><code class="language-odin">Vector3 :: [3]f32;
a := Vector3{1, 4, 9};
b := Vector3{2, 4, 8};
c := a + b;  // {3, 8, 17}
d := a * b;  // {2, 16, 72}
e := c != d; // true
</code></pre>

<h3 id="slices">Slices</h3>

<p>Slices look similar to arrays however, their length is not known at compile time. The type <code>[]T</code> is a slice with elements of type <code>T</code>. In practice, slices are much more common than arrays.</p>

<p>A slice is formed by specifying two indices, a low and high bound, separated by a colon:</p>

<pre><code class="language-odin">a[low : high]
</code></pre>

<p>This selects a half-open range which includes the lower element, but excludes the higher element.</p>

<pre><code class="language-odin">fibonaccis := [6]int{0, 1, 1, 2, 3, 5};
s: []int = fibonaccis[1:4]; // creates a slice which includes elements 1 through 3
fmt.println(s); // 1, 1, 2
</code></pre>

<p>Slices are like references to arrays; they do not store any data, rather describing a section, or slice, of an underlying data.</p>

<p>Internally, a slice stores a pointer to the data and an integer to store the length of the slice.</p>

<p>The built-in <code>len</code> proc returns the array&rsquo;s length.</p>

<pre><code class="language-odin">x: []int = ...;
length_of_x := len(x);
</code></pre>

<h4 id="slice-literals">Slice literals</h4>

<p>A slice literal is like an array literal without the length.
This an array literal:</p>

<pre><code class="language-odin">[3]int{1, 6, 3}
</code></pre>

<p>This is a slice literal which creates the same array as above, and then creates a slice that references it:</p>

<pre><code class="language-odin">[]int{1, 6, 3}
</code></pre>

<h4 id="slice-shorthand">Slice shorthand</h4>

<p>For the array:</p>

<pre><code class="language-odin">a: [6]int;
</code></pre>

<p>these slice expression are equivalent:</p>

<pre><code class="language-odin">a[0:6]
a[:6]
a[0:]
a[:]
</code></pre>

<h4 id="nil-slices">Nil slices</h4>

<p>The zero value of a slice is <code>nil</code>. A nil slice has a length of 0 and has not underlying memory it points to. Slices can be compared again <code>nil</code> and nothing else.</p>

<pre><code class="language-odin">s: []int;
if s == nil {
    fmt.println(&quot;s is nil!&quot;);
}
</code></pre>

<h3 id="dynamic-arrays">Dynamic arrays</h3>

<p>Dynamic arrays are similar to slices but their lengths may change during runtime. Dynamic arrays are resizeable and they are allocated using the current <a href="#context-system">context</a>&rsquo;s allocator.</p>

<pre><code class="language-odin">x: [dynamic]int;
</code></pre>

<p>Along with the built-in proc <code>len</code>, dynamic arrays also have <code>cap</code> which can used to determine the dynamic arrays current underlying capacity.</p>

<h4 id="appending-to-a-dynamic-array">Appending to a dynamic array</h4>

<p>It is common to append new elements to a dynamic array; this can be done so with the built-in <code>append</code> proc.</p>

<pre><code class="language-odin">x: [dynamic]int;
append(&amp;x, 123);
append(&amp;x, 4, 1, 74, 3); // append multiple values at once
</code></pre>

<h4 id="making-and-deleting-slices-and-dynamic-arrays">Making and deleting slices and dynamic arrays</h4>

<p>Slices and dynamic arrays can explicitly allocated with the built-in <code>make</code> proc.</p>

<pre><code class="language-odin">a := make([]int, 6);           // len(a) == 6
b := make([dynamic]int, 6);    // len(b) == 6, cap(b) == 6
c := make([dynamic]int, 0, 6); // len(c) == 0, cap(c) == 6
</code></pre>

<p>Slices and dynamic arrays can be deleted with the built-in <code>delete</code> proc.</p>

<pre><code class="language-odin">delete(a);
delete(b);
delete(c);
</code></pre>

<p><strong>Note:</strong> Slices created with <code>make</code> must be deallocated with <code>delete</code>, whereas a slice literal does not need to be deleted since it is just a slice of an underlying array.</p>

<p><strong>Note:</strong> There is not automatic memory management in Odin. Slices may not be allocated using an <a href="#allocators">allocator</a>.</p>

<h3 id="enumerations">Enumerations</h3>

<p>Enumeration types define a new type whose values consist of the ones specified. The values are ordered, for example:</p>

<pre><code class="language-odin">Direction :: enum{North, East, South, West};
</code></pre>

<p>The following holds:</p>

<pre><code class="language-odin">int(Direction.North) == 0
int(Direction.East)  == 1
int(Direction.South) == 2
int(Direction.West)  == 3
</code></pre>

<p>Enum fields can be assigned an explicit value:</p>

<pre><code class="language-odin">Foo :: enum {
    A,
    B = 4, // Holes are valid
    C = 7,
    D = 1337,
}
</code></pre>

<p>If an enumeration requires a specific size, a backing integer type can be specified. By default, <code>int</code> is used as the backing type for an enumeration.</p>

<pre><code class="language-odin">Foo :: enum u8 {A, B, C}; // Foo will only be 8 bits
</code></pre>

<p>Odin supports implicit selector expressions for enums:</p>

<pre><code class="language-odin">Foo :: enum {A, B, C};

f: Foo;
f = .A;

BAR :: bit_set[Foo]{.B, .C};

switch f {
case .A:
    fmt.println(&quot;foo&quot;);
case .B:
    fmt.println(&quot;bar&quot;);
case .C:
    fmt.println(&quot;baz&quot;);
}
</code></pre>

<p><a href="#using-statement"><code>using</code></a> can also be used with an enumeration to bring the fields into the current scope:</p>

<pre><code class="language-odin">main :: proc() {
    Foo :: enum {A, B, C};
    using Foo;
    a := A;

    using Bar :: enum {X, Y, Z};
    x := X;
}
</code></pre>

<h4 id="implicit-selector-expression">Implicit Selector Expression</h4>

<p>An <em>implicit selector expression</em> is an abbreviated way to access a member of an enumeration, in a context where type inference can determine the implied type. It has the following form:</p>

<pre><code class="language-odin">.member_name
</code></pre>

<p>For example:</p>

<pre><code class="language-odin">Direction :: enum{North, East, South, West};
d: Direction;
d = Direction.East;
d = .East;
</code></pre>

<p><strong>Note:</strong> This is preferred to <a href="#using-statement"><code>using</code></a> an enumeration as it does pollute the current scope.</p>

<h3 id="bit-sets">Bit sets</h3>

<p>The <code>bit_set</code> type models the mathematical notion of a set. A bit_set&rsquo;s element type can be either an enumeration or a range:</p>

<pre><code class="language-odin">Direction :: enum{North, East, South, West};

Direction_Set :: bit_set[Direction];

Char_Set :: bit_set['A'..'Z'];

Number_Set :: bit_set[0..&lt;10]; // bit_set[0..9]
</code></pre>

<p>Bit sets are implemented as bit vectors internally for high performance. The zero value of a bit set is either <code>nil</code> or <code>{}</code>.</p>

<pre><code class="language-odin">x: Char_Set;
x = {'A', 'B', 'Y'};
y: Direction_Set;
y = {.North, .West};
</code></pre>

<p>Bit sets support the following operations:</p>

<ul>
<li><code>A | B</code> - union of two sets</li>
<li><code>A &amp; B</code> - intersection of two sets</li>
<li><code>A &amp;~ B</code> - difference of two sets (A without B&rsquo;s elements)</li>
<li><code>A ~ B</code> - symmetric difference (Elements that are in A and B but not both)</li>
<li><code>A == B</code> - set equality</li>
<li><code>A != B</code> - set inequality</li>
<li><code>e in A</code> - set membership (A contains element e)</li>
<li><code>e notin A</code> - A does not contain element e</li>
<li><code>incl(&amp;A, elem)</code> - same as <code>A |= {elem};</code></li>
<li><code>excl(&amp;A, elem)</code> - same as <code>A &amp;~= {elem};</code></li>
</ul>

<p>Bit sets are often used to denote flags. This is much cleaner than defining integer constants that need to be bitwise or-ed together.</p>

<p>If a bit set requires a specific size, the underlying integer type can be specified:</p>

<pre><code class="language-odin">Char_Set :: bit_set['A'..'Z'; u64];
#assert(size_of(Char_Set) == size_of(u64));
</code></pre>

<h3 id="pointers">Pointers</h3>

<p>Odin has pointers. A pointer is an memory address of a value. The type <code>^T</code> is a pointer to a <code>T</code> value. Its zero value is <code>nil</code>.</p>

<pre><code class="language-odin">p: ^int;
</code></pre>

<p>The <code>&amp;</code> operator takes the address to its operand (if possible):</p>

<pre><code class="language-odin">i := 123;
p := &amp;i;
</code></pre>

<p>The <code>^</code> operator dereferences the pointer&rsquo;s underlying value:</p>

<pre><code class="language-odin">fmt.println(p^); // read  i through the pointer p
p^ = 1337;       // write i through the pointer p
</code></pre>

<p><strong>Note:</strong> C programmers may be used to using <code>*</code> to denote pointers. In Odin, the <code>^</code> syntax is borrowed from Pascal. This is to keep the convention of the type on the left and its usage on the right:</p>

<pre><code class="language-odin">p: ^int; // ^ on the left
x := p^; // ^ on the right
</code></pre>

<p><strong>Note:</strong> Unlike C, Odin has no pointer arithmetic. If you need a form of pointer arithmetic, please use the <code>ptr_offset</code> and <code>ptr_sub</code> procedures in the <code>&quot;core:mem&quot;</code> package.</p>

<h3 id="structs">Structs</h3>

<p>A <code>struct</code> is a record type in Odin. It is a collection of fields. Struct fields are accessed by using a dot:</p>

<pre><code class="language-odin">Vector2 :: struct {
    x: f32,
    y: f32,
}
v := Vector2{1, 2};
v.x = 4;
fmt.println(v.x);
</code></pre>

<p>Struct fields can be accessed through a struct pointer:</p>

<pre><code class="language-odin">v := Vector2{1, 2};
p := &amp;v;
p.x = 1335;
fmt.println(v);
</code></pre>

<p>We could write <code>p^.x</code>, however, it is to nice abstract the ability to not explicitly dereference the pointer. This is very useful when refactoring code to use a pointer rather than a value, and vice versa.</p>

<h4 id="struct-literals">Struct literals</h4>

<p>A struct literal can be denoted by providing the struct&rsquo;s type followed by <code>{}</code>. A struct literal must either provide all the arguments or none:</p>

<pre><code class="language-odin">Vector3 :: struct {
    x, y, z: f32,
}
v: Vector3;
v = Vector3{}; // Zero value
v = Vector3{1, 4, 9};
</code></pre>

<p>You can list just a subset of the fields if you specify the field by name (the order of the named fields does not matter):</p>

<pre><code class="language-odin">v := Vector3{z=1, y=2};
assert(v.x == 0);
assert(v.y == 2);
assert(v.z == 1);
</code></pre>

<h4 id="struct-tags">Struct tags</h4>

<p>Structs can tagged with different memory layout and alignment requirements:</p>

<pre><code class="language-odin">struct #align 4 {...} // align to 4 bytes
struct #packed {...} // remove padding between fields
struct #raw_union {...} // all fields share the same offset (0). This is the same as C's union
</code></pre>

<h3 id="unions">Unions</h3>

<p>A <code>union</code> in Odin is a discriminated union, also known as a tagged union or sum type. The zero value of a union is <code>nil</code>.</p>

<pre><code class="language-odin">Value :: union {
    bool,
    i32,
    f32,
    string,
}
v: Value;
v = &quot;Hellope&quot;;

// type assert that `v` is a `string` and panic otherwise
s1 := v.(string);

// type assert but with an explicit boolean check. This will not panic
s2, ok := v.(string);
</code></pre>

<h4 id="type-switch-statement">Type switch statement</h4>

<p>A type switch is a construct that allows several type assertions in series. A type switch is like a regular switch statement, but the cases are types (not values). For a union, the only case types allowed are that of the union.</p>

<pre><code class="language-odin">value: Value = ...;
switch v in value {
case string:
    #assert(type_of(v) == string);

case bool:
    #assert(type_of(v) == bool);

case i32, f32:
    // This case allows for multiple types, therefore we cannot know which type to use
    // `v` remains the original union value.
    #assert(type_of(v) == Value);
case:
    // Default case
    // In this case, it is `nil`
}
</code></pre>

<h3 id="maps">Maps</h3>

<p>A <code>map</code> maps keys to values. The zero value of a map is <code>nil</code>. A <code>nil</code> map has no keys. The built-in <code>make</code> proc returns an initialized map using the current <a href="#context-system">context</a>, and <code>delete</code> can be used to delete a map.</p>

<pre><code class="language-odin">m := make(map[string]int);
defer delete(m);
m[&quot;Bob&quot;] = 2;
fmt.println(m[&quot;Bob&quot;]);
</code></pre>

<p>To insert or update an element of a map:</p>

<pre><code class="language-odin">m[key] = elem;
</code></pre>

<p>To retrieve an element:</p>

<pre><code class="language-odin">elem = m[key];
</code></pre>

<p>To remove an element:</p>

<pre><code class="language-odin">delete_key(&amp;m, key);
</code></pre>

<p>If an element of a key does not exist, the zero value of the element will be returned. To check to see if an element exists can be done in two ways:</p>

<pre><code class="language-odin">elem, ok := m[key]; // `ok` is true if the element for that key exists
</code></pre>

<p>or</p>

<pre><code class="language-odin">ok := key in m; // `ok` is true if the element for that key exists
</code></pre>

<p>The first approach is called the &ldquo;comma ok idiom&rdquo;.</p>

<h3 id="procedure-type">Procedure type</h3>

<p>A procedure type is internally a pointer to a procedure in memory. <code>nil</code> is the zero value a procedure type.</p>

<p>Examples:</p>

<pre><code class="language-odin">proc(x: int) -&gt; bool
proc(c: proc(x: int) -&gt; bool) - (i32, f32)
</code></pre>

<h4 id="calling-conventions">Calling conventions</h4>

<p>Odin supports the following calling conventions:</p>

<ul>
<li><strong>odin</strong> - default convention used for an Odin <strong>proc</strong>. It is the same <strong>cdecl</strong> but passes an implicit <code>context</code> pointer on each call. (<strong>Note:</strong> This is subject to change)</li>
<li><strong>contextless</strong> - This is the same as <strong>odin</strong> but without the implicit <code>context</code> pointer.</li>
<li><strong>stdcall</strong> or <strong>std</strong> &ndash; This is the stdcall convention as specified by Microsoft.</li>
<li><strong>cdecl</strong> or <strong>c</strong> &ndash; This is the default calling convention generated of a procedure in C.</li>
<li><strong>fastcall</strong> or <strong>fast</strong> - This is a compiler dependent calling convention.</li>
<li><strong>none</strong> - This is a compiler dependent calling convention which will do nothing to parameters</li>
</ul>

<p>Most calling conventions exist only to interface with foreign windows code.</p>

<p>The default calling convention is <strong>odin</strong>, unless it is within a <code>foreign</code> block which it is then <strong>cdecl</strong>.</p>

<p>A procedure type with a different calling convention can be declared like the following:</p>

<pre><code class="language-odin">proc &quot;c&quot; (n: i32, data: rawptr)
proc &quot;contextless&quot; (s: []int)
</code></pre>

<p>Procedure types are only compatible with the procedures that have the same calling convention and parameter types.</p>

<h3 id="bit-fields">Bit fields</h3>

<p>A <code>bit_field</code> is a record type which allows you to define named integer fields with specific bit widths:</p>

<pre><code class="language-odin">Foo :: bit_field {
    width_validated: 1,
    height_validated: 1,
    age: 3,
}
</code></pre>

<p>This data struct will be 1 byte wide even though it requires only 5 bits of information.
The memory layout of a <code>bit_field</code> will directly map to an integer:</p>

<pre><code class="language-odin">width_validate == (x&gt;&gt;0) &amp; 0b1
height_validated == (x&gt;&gt;1) &amp; 0b1
age == (x&gt;&gt;2) &amp; 0b111
</code></pre>

<h3 id="typeid-type">&lsquo;typeid&rsquo; type</h3>

<p>A <code>typeid</code> is a unique identifier for an Odin type. This construct is used by the <code>any</code> type to denote what the underlying data&rsquo;s type is.</p>

<pre><code class="language-odin">a := typeid_of(bool);
i: int = 123;
b := typeid_of(type_of(i));
</code></pre>

<p>A <code>typeid</code> can be mapped to relevant type information which can be used in applications such as printing types and editing data:</p>

<pre><code class="language-odin">import &quot;core:runtime&quot;

main :: proc() {
    u := u8(123);
    id := typeid_of(type_of(u));
    info: ^runtime.Type_Info;
    info = type_info_of(id);
}
</code></pre>

<h3 id="any-type">&lsquo;any&rsquo; Type</h3>

<p>An <code>any</code> type can reference any data type. Internally it contains a pointer to the underlying data and its relevant <code>typeid</code>. This is a very useful construct in order to have a runtime type safe printing procedure.</p>

<p><strong>Note:</strong> The <code>any</code> value is only valid for as long as the underlying data is still valid. Passing a literal to an <code>any</code> will allocate the literal in the current stack frame.</p>

<p><strong>Note:</strong> It is highly recommended that you do not use this unless you know what you are doing. Its primary use is for printing procedures.</p>

<h2 id="using-statement">Using statement</h2>

<p><code>using</code> can used to bring entities declared in a scope/namespace into the current scope. This can be applied to import declarations, import names, struct fields, procedure fields, and struct values.</p>

<pre><code class="language-odin">// imports all the exported entities from the `foo` package into this file scope
using import &quot;foo&quot;
</code></pre>

<pre><code class="language-odin">import &quot;foo&quot;
bar :: proc() {
    // imports all the exported entities from the `foo` package into this scope
    using foo;
}
</code></pre>

<p><strong>Note:</strong> It is not advised that to do <code>using import</code> as it pollutes the file&rsquo;s scope.</p>

<h3 id="using-statement-with-structs">Using statement with structs</h3>

<p>Let&rsquo;s take a very simple entity struct:</p>

<pre><code class="language-odin">Vector3 :: struct{x, y, z: f32};
Quaternion :: struct{x, y, z, w: f32};
Entity :: struct {
    position: Vector3,
    orientation: Quaternion,
}
</code></pre>

<p>It can used like this:</p>

<pre><code class="language-odin">foo :: proc(entity: ^Entity) {
    fmt.println(entity.position.x, entity.position.y, entity.position.z);
}
</code></pre>

<p>The entity members can be brought into the procedure scope by <code>using</code> it:</p>

<pre><code class="language-odin">foo :: proc(entity: ^Entity) {
    using entity;
    fmt.println(position.x, position.y, position.z);
}
</code></pre>

<p>The <code>using</code> can be applied to the parameter directly:</p>

<pre><code class="language-odin">foo :: proc(using entity: ^Entity) {
    fmt.println(position.x, position.y, position.z);
}
</code></pre>

<p>It can also be applied to sub-fields:</p>

<pre><code class="language-odin">foo :: proc(entity: ^Entity) {
    using entity.position;
    fmt.println(x, y, z);
}
</code></pre>

<p>We can also apply the <code>using</code> statement to the struct fields directly, making all the fields of <code>position</code> appear as if they on <code>Entity</code> itself:</p>

<pre><code class="language-odin">Entity :: struct {
    using position: Vector3,
    orientation: Quaternion,
}
foo :: proc(entity: ^Entity) {
    fmt.println(entity.x, entity.y, entity.z);
}
</code></pre>

<h3 id="subtype-polymorphism">Subtype polymorphism</h3>

<p>It is possible to get subtype polymorphism, similar to inheritance-like functionality in C++, but without the requirement of vtables or unknown struct layout:</p>

<pre><code class="language-odin">Frog :: struct {
    ribbit_volume: f32,
    using entity: Entity,
    colour: Colour,
}

frog: Frog;
// Both work
foo(frog);
frog.x = 123;
</code></pre>

<p><strong>Note:</strong> <code>using</code> can be applied to arbitrarily many things, which allows the ability to have multiple subtype polymorphism (but also its issues).</p>

<p><strong>Note:</strong> <code>using</code>&rsquo;d fields can still be referred by name.</p>

<h2 id="implicit-context-system">Implicit context system</h2>

<p>TODO</p>

<h3 id="allocators">Allocators</h3>

<p>TODO</p>

<h2 id="foreign-system">Foreign system</h2>

<p>It is sometimes necessarily to interface with foreign code, such as a C library. In Odin, this is achieved through the <code>foreign</code> system. You can &ldquo;import&rdquo; a library into the code using the same semantics as a normal import declaration:</p>

<pre><code class="language-odin">foreign import kernel32 &quot;system:kernel32.lib&quot;
</code></pre>

<p>This <code>foreign import</code> declaration will create a &ldquo;foreign import name&rdquo; which can then be used to associate entities within a foreign block.</p>

<pre><code class="language-odin">foreign import kernel32 &quot;system:kernel32.lib&quot;
foreign kernel32 {
    ExitProcess :: proc &quot;stdcall&quot; (exit_code:  u32) ---;
}
</code></pre>

<p>Foreign procedure declarations have the <strong>cdecl</strong>/<strong>c</strong> calling convention by default unless specified otherwise. Due to foreign procedures do not have a body declared within this code, you need append the <code>---</code> symbol to the end to distinguish it as a procedure literal without a body and not a procedure type.</p>

<p>The attributes system can be used to change specific properties of entities declared within a block:</p>

<pre><code class="language-odin">@(default_calling_convention = &quot;std&quot;)
foreign kernel32 {
    @(link_name=&quot;GetLastError&quot;) get_last_error :: proc() -&gt; i32 ---;
}
</code></pre>

<p>Available attributes for foreign blocks:</p>

<pre><code class="language-odin">default_calling_convention=&lt;string&gt;
    default calling convention for procedures declared within this foreign block
link_prefix=&lt;string&gt;
    prefix that needs to be appended to the linkage names of the entities except where the link name has been explicitly overridden
</code></pre>

<h2 id="parametric-polymorphism">Parametric polymorphism</h2>

<p>Parametric polymorphism, commonly referred to as &ldquo;generics&rdquo;, allow the user to create a procedure or data that can be written <em>generically</em> so it can handle values in the same manner.</p>

<p>Note: Within the Odin code base and documentation, the nickname &ldquo;parapoly&rdquo; is usually used.</p>

<h3 id="explicit-parametric-polymorphism">Explicit parametric polymorphism</h3>

<p>Explicit parametric polymorphism means that the types of the parameters must be explicitly provided.</p>

<h4 id="procedures-1">Procedures</h4>

<p>To specify that a parameter is &ldquo;constant&rdquo;, the parameters name must be prefixed with a dollar sign <code>$</code>. The following example takes two constant parameters to initialize an array of known length:</p>

<pre><code class="language-odin">make_f32_array :: inline proc($N: int, $val: f32) -&gt; (res: [N]f32) {
    for _, i in res {
        res[i] = val*val;
    }
    return;
}

array := make_f32_array(3, 2);
</code></pre>

<p>Types can also be explicitly passed with specifying that the <code>typeid</code> parameter is constant:</p>

<pre><code class="language-odin">my_new :: proc($T: typeid) -&gt; ^T {
    return (^T)(alloc(size_of(T), align_of(T)));
}

ptr := my_new(int);
</code></pre>

<h4 id="data-types">Data types</h4>

<p>Structures and union may have polymorphic parameters. The <code>$</code> prefix is optional for record data types as all parameters must be &ldquo;constant&rdquo;.
Parapoly struct:</p>

<pre><code class="language-odin">Table_Slot :: struct(Key, Value: typeid) {
    occupied: bool,
    hash:    u32,
    key:     Key,
    value:   Value,
}
slot: Table_Slot(string, int);
</code></pre>

<p>Parapoly union:</p>

<pre><code class="language-odin">Error :: enum {Foo0, Foo1, Foo2};
Param_Union :: union(T: typeid) {T, Error};
r: Param_Union(int);
r = 123;
r = Error.Foo0;
</code></pre>

<h3 id="implicit-parametric-polymorphism">Implicit parametric polymorphism</h3>

<p>Implicit implies that the type of parameter is inferred from its input. In this case, the dollar sign <code>$</code> can be placed on the type.</p>

<p>Note: Within the Odin code base and documentation, the name &ldquo;polymorphic name&rdquo; is usually used.</p>

<h4 id="procedures-2">Procedures</h4>

<pre><code class="language-odin">foo :: proc($N: $I, $T: typeid) -&gt; (res: [N]T) {
    // `N` is the constant value passed
    // `I` is the type of N
    // `T` is the type passed
    fmt.printf(&quot;Generating an array of type %v from the value %v of type %v\n&quot;,
               typeid_of(type_of(res)), N, typeid_of(I));
    for i in 0..&lt;N {
        res[i] = i*i;
    }
    return;
}

T :: int;
array := foo(4, T);
for v, i in array {
    assert(v == T(i*i));
}
</code></pre>

<h4 id="specialization">Specialization</h4>

<p>In some cases, you may want to specify that a type must be a specialization of a certain type.</p>

<pre><code class="language-odin">// Only allow types that are specializations of a (polymorphic) slice
make_slice :: proc($T: typeid/[]$E, len: int) -&gt; T {
    return make(T, len);
}
</code></pre>

<pre><code class="language-odin">Table_Slot :: struct(Key, Value: typeid) {
    occupied: bool,
    hash:     u32,
    key:      Key,
    value:    Value,
}
Table :: struct(Key, Value: typeid) {
    count:     int,
    allocator: mem.Allocator,
    slots:     []Table_Slot(Key, Value),
}

// Only allow types that are specializations of `Table`
allocate :: proc(table: ^$T/Table, capacity: int) {
    ...
}

// find :: proc(table: ^$T/Table, key: T.Key) -&gt; (T.Value, bool) {
find :: proc(table: ^Table($Key, $Value), key: Key) -&gt; (Value, bool) {
    ...
}
</code></pre>

<h2 id="useful-idioms">Useful idioms</h2>

<h3 id="basic-idioms">Basic idioms</h3>

<h4 id="if-statements-with-initialization">If-statements with initialization</h4>

<pre><code class="language-odin">if str, ok := value.(string); ok {
    ...
} else {
   ...
}
</code></pre>

<h4 id="iterating-through-slices-of-structs-by-value-or-by-reference">Iterating through slices of structs by value or by reference</h4>

<pre><code class="language-odin">Foo :: struct {
    f: float,
    i: int,
}

foos := make([]Foo, num);

// By-value basic ranged-based loop, with implicit indexing
for v, j in foos {
    using v;
    fmt.println(i, v, f, i);
}

// Alternative range-based loop, with explicit indexing
for _, j in foos {
    using foo := foos[j]; // copy
    fmt.println(j, foo, f, i);
}

// By-reference range-based explicit indexing loop
for _, j in foos {
    using foo := &amp;foos[j]; // &quot;reference&quot;, changes to `f` or `i` are visible outside this scope
    fmt.println(j, foo, f, i);
}
</code></pre>

<h4 id="defer-if">&lsquo;defer if&rsquo;</h4>

<pre><code class="language-odin">defer if cond {
}
</code></pre>

<h3 id="advanced-idioms">Advanced idioms</h3>

<p>Subtype polymorphism with runtime type safe down casting:</p>

<pre><code class="language-odin">Entity :: struct {
    id:   u64,
    name: string,

    derived: any,
}

Frog :: struct {
    using entity: Entity,
    volume: f32,
    jump_height: i32,
}


new_entity :: proc($T: typeid) -&gt; ^T {
    e := new(T);
    e.derived = e^;
    return e;
}

entity: ^Entity = new_entity(Frog);
switch e in entity.derived {
case Frog:
    fmt.println(&quot;Ribbit:&quot;, e.volume);
}
</code></pre>

<h2 id="extra-information">Extra information</h2>

<p>More details can be found on the <a href="https://github.com/odin-lang/Odin/wiki">Github wiki for Odin</a>.
Some of this information includes:
- <a href="https://github.com/odin-lang/Odin/wiki/Compiler-Flags">Compiler Flags</a>
- <a href="https://github.com/odin-lang/Odin/wiki/Attributes-and-Tags">Attributes and Tags</a>
- <a href="https://github.com/odin-lang/Odin/wiki/Built-in-Procedures">Built in Procedures</a>
- <a href="https://github.com/odin-lang/Odin/wiki/Keywords-and-Operators">Keywords and Operators</a>
- &hellip;and more</p>


</article>
</main>
<footer>
&copy; 2016&ndash;2019 Ginger Bill
</footer>
</div>
</body>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
  (function addHeadingLinks(){
    var article = document.getElementsByClassName('article-meta')[0];
    var headings = article.querySelectorAll('h1, h2, h3');
    headings.forEach(function(heading){
      if (heading.id){
        var a = document.createElement('a');
        a.innerHTML = heading.innerHTML;
        a.href = '#'+heading.id;
        heading.innerHTML = '';
        heading.appendChild(a);
      }
    });
  })();

  const DARK  = '(prefers-color-scheme: dark)';
  const LIGHT = '(prefers-color-scheme: light)';

  function setColourScheme(scheme) {
    console.log(scheme);
    if (scheme == 'dark') {

    } else if (scheme == 'light') {

    }
  }


  (function changeStyle(){
    function detectColourScheme() {
      if (!window.matchMedia) {
        return;
      }

      function listener({matches, media}) {
        if (!matches) {
          return;
        }
        if (media == DARK) {
          setColourScheme('dark');
        } else if (media == LIGHT) {
          setColourScheme('light');
        }
      }

      const mqDark  = window.matchMedia(DARK);
      const mqLight = window.matchMedia(LIGHT);
      mqDark.addListener(listener);
      mqLight.addListener(listener);
    }
  })();
</script>
</html>

